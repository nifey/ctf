# Challenge: Eat Sleep Trace Repeat (rev)

Downloaded files: trace.txt (tracefile)

$ ./chall
enter password: zh3r0{xxxxxx...}
search complete
$ # :)

# Solution

The challenge here is that we don't have the binary. Instead we have an assembly instruction trace.
The user who executed the binary has entered the flag as the password.

Now let's look at the trace.
There are four syscalls.
1. Write to stdout (must be the "enter password" string)
2. Read from stdin (must be the flag)
3. Write to stdout (must be the "Search Complete" string)
4. Exit (at the end)

The strings and other data seem to be after memory address 0x402800.

By using grep to find all Call instructions, we can see that there are 5 functions.

- call 0x401068
  - This looks like the entry function or main function (called at the very beginning)
  - Prints the string at 0x4028d0 which should be the prompt asking for the password

- call 0x401005
  - This function reads 100 characters from stdin and stores in 0x402808

- call 0x40105f
  - Stores 0x41424344 at 0x402000 (This value is then used for random character generation)

- Then there is the following loop that runs for 2048 times.
  I have given the rough disassembly (found manually)
```
for r15 in 0..2048
  call 0x401023
mov byte ptr [r15 + 0x402008], al
```

- call 0x401023
  - This function generates random characters which is returned in al
  - The rough disassembly of the function is given below
```
rcx = [0x402000]
rdx = rcx

rdx >>= 12
rcx = rcx ^ rdx
rdx = rcx

rdx <<= 25
rcx = rcx ^ rdx
rdx = rcx

rdx >>= 27
rcx = rcx ^ rdx
rdx = rcx

rax = 0x2545f4914f6cdd1d
rdx:rax = rax * rcx
[0x402000] = rcx
```

- After that we search for each input character in the generated memory
```
for rsi in 0..100
  dil = [rsi + 0x402808]

  call 0x401106
    rbx = rdi
    for rdx in 0..0x7ff
      al = [rdx + 0x402008]
      if al != bl (0x401122)
        continue
      else
        rdx-- (0x401126)
        rax = rdx
        ret

byte ptr [rsi+0x40286c] = al
```

The binary is first generating 2048 random bytes in memory.
Then it searches for each input character in the generated memory and moves the index where each character was found to 0x40286c (100 bytes).

Then it prints 16 characters at 0x4028e1 which is "Search Complete"

So we can find what the user entered by regenerating the random characters and using the 
number of times the search loop executed as the index into the generated characters.

The instructions of interest are at 0x401122 and 0x401126.
Using these two instructions we can find the user input during the program execution

[rev.py](rev.py) generates the same random characters that was generated by the binary.
It then finds the flag using the indices found using [find\_indices.sh](find_indices.sh) script.

# Flag
```
zh3r0{d1d_y0u_enjoyed_r3v3rs1ng_w1th0ut_b1n4ry_?}
```
